#!/bin/bash
[[ ! -v _red ]] && { 
_green="$(tput setaf 2)"
_red="$(tput setaf 1)"
_white="$(tput setaf 255)"
_bold="$(tput bold)"
_nc="$(tput sgr 0)"
}

function _conditionalRender() {
  while read line; do
    if [[ "$line" == '$(' ]]; then 
      continue
    elif [[ "${line::2}" =~ \<[A-z]|\</|\"\<|\'\<  ]]; then
      if [[ ${line: -5} == "%AND%" ]]; then 
        line="${line%%\%AND\%}"
        line="${line%% }"
        @unquote line
        local appendand=true
      else 
          @unquote line
      fi
      output+=" printf '%s' \""
      while read line; do
      [[ "$nextline" ]] && local buf="$line" && line="$nextline" && nextline="$buf"
        
        if echo "${line## }" | grep -qE '^[[:space:]]*</?([A-Z][a-zA-Z0-9]*)\b'; then 
          [[ "$line" =~ /\>.* ]] && nextline=$(sed 's|^.*/>\(.*\)|\1|' <<< "$line") && line="${line//$nextline}" 
          line="${line%%\/\>}"
          line="${line%%\>}"
          line="${line##\<}"
          output+="\\\`$line\\\`"$'\n' 
        else 
          output+="${line//\"/\\\"}"
        fi
      done < <(echo "$line" | sed 's|\([a-zA-Z0-9|"|\@|\/]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g')
      [[ $appendand == true ]] && output+=$'" %AND%' && unset appendadd || output+=$'"\n'
    else 
      output+=" $line"
    fi
  done
  output="${output%%)}"$'\n'
}

function @error() {
  [[ ${#FUNCNAME[@]} > 1 ]] && echo -n "(${FUNCNAME[1]}) " >&2
  echo "${_red}Error:${_nc} ${@}" >&2
}

function _render() {
local dom=false level=0 flevel=0 inscript=false output='' i=0 tag=''
local -a parent=() extra=()

while read -r line; do
  line="${line%% }"
  line="${line//&&/%AND%}"
  if [[ "$readchunk" ]]; then 
    if [[ "${line: -1}" != ')' ]]; then
      chunk+="${line}"$'\n' && continue
    else 
      chunk+="${line%%)}"$'\n'
      line=")"
      unset readchunk
    fi
  fi
  [[ "$line" == '' || "${line::1}" == '#' ]] && continue
  
  [[ "$line" =~ @render= ]] && @render_type "${line##@render=}" && continue
  if [[ "${line::1}" == "<" ]]; then
    while read -r line; do
      [[ "$nextline" ]] && local buf="$line" && line="$nextline" && nextline="$buf"
      [[ "$line" == '' || "${line::1}" == '#' ]] && continue
      if echo "${line## }" | grep -qE '^[[:space:]]*</?([A-Z][a-zA-Z0-9]*)\b'; then # regex if it's a custom element or native html
        [[ "$line" =~ /\>.* ]] && nextline=$(sed 's|^.*/>\(.*\)|\1|' <<< "$line") && line="${line//$nextline}" 
        line="${line%%\/\>}"
        line="${line%%\>}"
        line="${line##\<}"
        output+="$line"$'\n' # only keep the function and it's arguments
      else
        read tag attr <<< "$line"
        if [[ "$tag" =~ '<script' ]]; then
          if [[ "$attr" =~ text/x-bash ]]; then
            [[ "$type" =~ silent || ! -v bash_wasm_path ]] && inscript=bash-client-silent || inscript=bash-client
            output+=$'cat <<- "_EOF_"\n'
            [[ ! -v bash_wasm_path ]] && output+="<script>addServerAction(\`" || output+="<script>execute(\`"
          elif [[ "$attr" =~ text/x-bash ]]; then
            if [[ $__render_type == client ]]; then
              inscript=bash-client
              output+=$'cat <<- "EOF"\n<script>execute(`'
            else  
              inscript=bash 
            fi
          else
            inscript=js
            output+=$'cat <<- "_EOF_"\n'
            output+="$line"$'\n'
          fi
        elif [[ "$tag" =~ '</script' ]]; then 
          case "$inscript" in 
            js)
              output+=$'</script>\n_EOF_\n'
            ;;
            bash-client-silent)
              output+=$'`)</script>\n_EOF_\n'
            ;;
            bash-client)
              local uid=$(cat /proc/sys/kernel/random/uuid)
              output+="\`,'$uid')</script><div id='$uid'></div>"
              unset uid
              output+=$'\n_EOF_\n'
          esac
          inscript=false
        else
          case "$line" in
          on:*)
            line="${line%%\>}";
            line="${line##\<}";
            local arg attr key events;
            read el args <<< "$line";
            #set -- $args
            while read arg; do 
              IFS='=' read key value <<< "${arg}"; 
              @unquote value
              if [[ -z "$key" ]]; then 
                continue
              fi 
              case "$key" in
                js-on:*) key="${key//js-on:}"; events+="on${key,,}=\"$($value)\" " ;;
                server-on:*) key="${key//on:}"; _events+="on${key,,}=\"\$(addServerAction "$value")\" " ;;
                on:*) key="${key//on:}"; _events+="on${key,,}=\"execute(\`$value\`)\" " ;;
                on*)  events+="${key,,}=\"$value\" " ;;
                *)  attr+="$key=\"$value\" "
              esac
            done <<< "$args"
            output+="printf '%s' \"<$el $attr $events>'\""$'\n'
            unset el args key events arg
          ;;
          '</head>')
            [[ -v ismeta ]] && unset ismeta
          ;;
          '</'*|'<body'*|'<main'*|'<div'*)
            output+="printf '%s\n' '${line}'"$'\n'
          ;;
          '<head')
            local ismeta=true
          ;;
          *)
           [[ "$ismeta" ]] && output+="addMeta \"${line//\"/\\\"}\""$'\n' || output+="printf '%s' \"${line//\"/\\\"}\""$'\n'
          esac
        fi
        unset tag _
      fi 
    done < <(echo "$line" | sed 's|\([a-zA-Z0-9|"|\@|\/]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g')
  elif [[ "$line" =~ '{@children}'|'{cache}'|'{/cache}'|'@return' || "$inscript" =~ bash|js ]]; then 
    output+="$line"$'\n'
  elif [[ "$inscript" =~ bash-client ]]; then
    output+="$line"$'\n'
  elif [[ "${line::2}" =~ '$(' ]]; then
     #output+="echo \"$line\""$'\n'
   #line="${line//%AND%/\&\&$'\n'}"
    if [[ ! "$line" =~ ')' ]]; then
      readchunk=true
      line="${line//\$(/\$($'\n'  }"
      chunk="${line%%)}"$'\n'
      continue
    else 
      line="${line//\$(/\$($'\n'  }"
      line="${line%%)}"$'\n)'
      echo "render type: $__render_type"
      if [[ "$__render_type" == client ]]; then 
        output+=$'cat <<- "_EOF_"\n<script>execute(`'
        _conditionalRender <<<"${line//%AND%/%AND%$'\n'}"
        local uid=$(cat /proc/sys/kernel/random/uuid)
        output+="\`,'$uid')</script><div id='$uid'></div>"
        output+=$'\n_EOF_\n'
        unset uid
      else 
        _conditionalRender <<<"${line//%AND%/%AND%$'\n'}"
      fi
    fi
  elif [[ "${line}" == ')' && "$chunk" ]]; then
    echo "render type: $__render_type"
    if [[ "$__render_type" == client ]]; then 
      output+=$'cat <<- "_EOF_"\n<script>execute(`'
        _conditionalRender <<<"${chunk//%AND%/%AND%$'\n'}"
        local uid=$(cat /proc/sys/kernel/random/uuid)
        output+="\`,'$uid')</script><div id='$uid'></div>"
        output+=$'\n_EOF_\n'
        unset uid
    else 
      _conditionalRender <<<"${chunk//%AND%/%AND%$'\n'}"
    fi
  else 
    [[ "$line" =~ '{' && "$line" =~ '}' ]] && line=$(echo "$line" | sed 's|{\([^[:space:]]\+\)}|<a data-bind="\1"></a>|g')
    output+="printf '%s' \"${line//\"/\\\"}\""$'\n'
  fi 
done
#output="$(echo "$output" | sed 's|\(.*\)}|\1|')"
# <<< "${input}"
render_output="$output"
unset input output level flevel i inscript parent line nextline
} 

bashx() {
#set -x
if [ -f "$1" ]; then 
  input=$(sed -E 's#(.*)\@return[[:space:]](json|html)[[:space:]]*\{[[[:space:]]*]?(.*)[^^]\}(.*)$#\1\n\@return \2 \{\n\3\n}\n\4#g' "$1" | sed 's/^source.*bashx//g') 
else 
  return 1
fi
local time=$(date +%s%3N)

#local input=$(echo "${input//\\n}" | sed 's|\([a-zA-Z|"]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g') # split code into elements
local out1="${input//$'\n'/#NEWLIN#}" 
local out2=$(echo "$input" | awk 'function count(s, c) { n=0; for (i=1; i<=length(s); i++) if (substr(s, i, 1) == c) n++; return n } /^[[:space:]]*@return[[:space:]](html|json)[[:space:]]*{[[:space:]]*$/ { in_block=1; depth=1; print; next } in_block { o=count($0,"{"); c=count($0,"}"); depth+=o-c; print; if (depth==0) { in_block=0; print "\r" } }')
#echo "$out2" 
#return
while read -d $'\r' block; do
  #echo "${block}"
  block1="$block" # | sed  's|\([a-zA-Z0-9|"|\@|\/]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g')
 # block1="$block"
  if [[ "${block//$'\n'}" =~ 'html' ]]; then
    block1="${block1%%\}}"
    _render "" <<< "${block1/@return html \{}"
    local newblock="{"$'\n'"${render_output}"$'\n'"}"
  elif [[ "${block//$'\n'}" =~ "json" ]]; then 
    local newblock="${block/@return json}"
    newblock="${newblock//\};/\}}"
    newblock="${newblock//$'\n'/ }"
    newblock=$(cat <<-eof
echo "${newblock//\"/\\\"}"
eof
)
    newblock="${newblock//  }"
  fi
  newblock="${newblock##$'\n'}"
  block="${block//$'\n'/#NEWLIN#}"
  block="${block//\[/\\\[}"
  block="${block//\]/\\\]}"
  out1="${out1//$block/${newblock% }}"
done <<< "$out2"
[[ "$BASHX_VERBOSE" ]] && { 
  printf "%s\n" "[$_greenâœ“$_nc] Compiled $1 ($(($(date +%s%3N)-time))ms)" 
}
unset input out out2 block time block1 render_output
#echo "${out1//#NEWLIN#/$'\n'}" 
#return
if [[ "$2" ]]; then 
  echo "$1:"
  echo "${out1//#NEWLIN#/$'\n'}" 
  printf "\n"
else 
  BASHX_FILENAME="$(readlink -f "$1")"
  out1="${out1//\%AND\%/\&\&}"
  eval "${out1//#NEWLIN#/$'\n'}"
fi
unset out out1 out2 block block1
#set -x
}
function @parse {
  _events=''
  for arg in "$@"; do 
    IFS='=' read key value <<< "${arg}"; 
    if [[ -z "$key" ]]; then 
      continue
    fi 
    case "$key" in
      js-on:*)
        key="${key//js-on:}"
        value="${value##\'}"
        value="${value//\'}"
        _events+="on${key,,}=\"$($value)\" "
        ;;
      on:*)
        key="${key//on:}"
        value="${value##\'}"
        value="${value//\'}"
        _events+="on${key,,}='execute('$value')"
        ;;
      on*)
        _events+="${key,,}=\"$value\" "
      ;;
      *) 
        [[ "$BASH_BROWSER" ]] && export $key="$value" || printf -v "$key" "%s" "$value"
      esac
  done
  unset arg key value
}


function @exclude {
  local list="${1}" result=()
  for arg in "${@:2}"; do
    IFS='=' read key value <<< "${arg}"; 
    [[ -z "$key" ]] && continue
    printf -v "$key" "%s" "$value"
    [[ "$key" =~ $list ]] && continue 
    result+=("$key='$value'")
  done
  set -- ${result[@]}
}

function @require {
  for arg in $@; do 
    declare -F $arg || echo "Error: required $arg is not found" 
  done
}

function @unquote {
 for key in "$@"; do
    local -n key1=$key
    key1="${key1%%\'}"; key1="${key1##\'}"; key1="${key1##\"}"; printf -v "$key" "${key1%%\"}"; 
  done
}

function @wrapper() {
  for key in $@; do 
    [ -z "$(declare -F "$key")" ] && return
    eval "$(declare -f "$key" | sed "s+{@children};+}; /${key}() {+g")"
  done
}

function @render_type() {
  case "${1,,}" in
    client) __render_type=client ;;
    server) __render_type=server ;;
         *) @error "Invalid render type provided" && return 1
  esac
}

function import() {
  # Syntax: import <filename>  || import <filename> as <ElementAlias>
  # import <function> from <filename> || import <function> from <filename> as <ElementAlias>
  local name filename
  [ -z "$name" ] && name="$1"
  shift
  if [[ "$1" == "as" ]]; then
    if [ -d "$name" ]; then 
      name="$name/index.sh"
    elif [ ! -f "$name" ]; then
      echo "$name not found to import."
      exit 1
    fi
    shift
    if [ -z "$1" ]; then
      fn_name=""${name%.*}""
    else
      fn_name="$1"
    fi
    eval "${fn_name}() { $(cat "$name") }"
  elif [[ "$1" == "from" ]]; then
    shift
    filename="$1"
    if [ ! -f "$filename" ]; then
      error "$name not found to import."
      exit 1
    fi
    [[ "$filename" =~ .shx|.bashx ]] && local funcout="$(bashx "$filename" && declare -f "$name" && declare -f "/$name")" || local funcout="$(. "$filename" && declare -f "$name")"
    [ -z "$funcout" ] && error "$name is not found in $filename" && return 1
    shift
    if [[ "$1" == "as" ]]; then
      shift
      if [ -z "$1" ]; then
        fn_name="${name%.*}"
      else
        fn_name="$1"
      fi
      eval "${funcout/$name/$fn_name}"
    else
      [[ "$funcout" ]] && eval "$funcout"
    fi
  else 
    [[ -n "$name" ]] && { [[ "$name" =~ .shx|.bashx ]] && bashx "$name" || source "$name"; }
  fi
}

declare -F exportFunction >/dev/null && exportFunction @require @unquote @parse @exclude

if (return 0 2>/dev/null); then
    echo "${BASH_SOURCE[@]} $0"
  [[ -z "$BASHX_NESTED" ]] && BASHX_NESTED=true && bashx "${BASH_SOURCE[-1]}" && exit
elif [[ -z $BASHX_NESTED ]]; then
  BASHX_NESTED=true 
  if [ -z "$1" ]; then
    @error "Invalid usage. Use $0 [filename]"
    exit 1
  elif [ -f "$1" ]; then
    filename="$1" 
    [[ "$filename" != "${filename##*/}" ]] && cd "${filename%/*}" && filename="${filename##*/}"
    bashx "$filename"
    exit
  else
    @error "$1 is not found"
    exit 1
  fi
fi